"""
Module: app_brain

This module defines the AppBrain class for handling text-based application logic.

Classes:
- AppBrain: A class representing the brain of a text-based application.

Usage Example:
--------------
from app_brain import AppBrain

# Create an instance of AppBrain
app_brain = AppBrain(computer_text="Example Text", user_text="")

# Access the last index property
last_index = app_brain.last_index

# Check if the last character entered by the user 
 matches the corresponding character in the computer text
is_last_char_same = app_brain.is_last_char_same()

# Check if the current round is over
is_round_over = app_brain.is_round_over()

# Set the round mistakes property
app_brain.round_mistakes = 2

# Count the errors in the current round
round_errors = app_brain.count_round_errors()

# Calculate the score based on total characters, errors, and test time
score = AppBrain.calculate_score(total_chars=100, errors=5, test_time=60000)
"""


class AppBrain:
    """
    A class representing the brain of a text-based application.

    Attributes:
    - computer_text (str): The text generated by the computer.
    - user_text (str): The text entered by the user.
    - round_mistakes (int): The number of mistakes made in the current round.
    - _last_index (int): The index of the last character entered by the user.

    Methods:
    - __init__(self, computer_text: str = None, user_text: str = None):
        Constructor to initialize the AppBrain.
    - calculate_score(total_chars: int, errors: int, test_time: int = 60000):
        Calculate the score based on total characters, errors, and test time.
    - is_last_char_same(self): Check if the last character entered by the user matches
        the corresponding character in the computer text.
    - is_round_over(self): Check if the current round is over.
    - count_round_errors(self) -> int: Count the errors in the current round.
    """

    def __init__(self, computer_text: str = None, user_text: str = None):
        self.computer_text = computer_text
        self.user_text = user_text
        self.round_mistakes = 0
        self._last_index = len(self.user_text) - 1

    @staticmethod
    def calculate_score(total_chars: int, errors: int, test_time: int = 60000) -> tuple:
        """
        Calculate the score based on total characters, errors, and test time.

        Parameters:
        - total_chars (int): Total number of characters.
        - errors (int): Number of errors made.
        - test_time (int): Test time in milliseconds (default is 60000).

        Returns:
        - tuple: A tuple containing the calculated score and the number of errors.
        """
        return (
            int((total_chars / 5 - errors) / ((test_time / 1000) / 60)),
            int(errors),
        )

    @property
    def last_index(self) -> int:
        """
        Get the index of the last character entered by the user.

        Returns:
        - int: Index of the last character.
        """
        return self._last_index

    def is_last_char_same(self) -> bool:
        """
        Check if the last character entered by the user matches the
            corresponding character in the computer text.

        Returns:
        - bool: True if the last characters match, False otherwise.
        """
        if len(self.user_text) == 0:
            return False
        return self.computer_text[self._last_index] == self.user_text[-1]

    def is_round_over(self) -> bool:
        """
        Check if the current round is over.

        Returns:
        - bool: True if the round is over, False otherwise.
        """
        if len(self.user_text.strip()) > len(self.computer_text.strip()):
            return True
        return len(self.computer_text.strip()) == len(self.user_text.strip())

    @property
    def round_mistakes(self) -> int:
        """
        Get the number of mistakes made in the current round.

        Returns:
        - int: Number of mistakes.
        """
        return self._round_mistakes

    @round_mistakes.setter
    def round_mistakes(self, new_value):
        """
        Set the number of mistakes made in the current round.

        Parameters:
        - new_value (int): The new value for round mistakes.

        Raises:
        - ValueError: If the new value is greater than the number of letters in the computer text.
        """
        if new_value > len(self.computer_text):
            raise ValueError("More mistakes than letters!")
        self._round_mistakes = new_value

    def count_round_errors(self) -> int:
        """
        Count the errors in the current round.
        If the round is not complete, but the timer reached 0, evaluate existing input.

        Returns:
        - int: Number of errors.
        """
        computer_words = self.computer_text.strip().split(" ")
        user_words = self.user_text.strip().split(" ")
        errors = 0

        # find which widget has the least num of words
        min_word_count = min(len(computer_words), len(user_words))

        for word_index in range(min_word_count):
            min_word_length = min(
                len(user_words[word_index]), len(computer_words[word_index])
            )

            # compare their chars
            for letter_index in range(min_word_length):
                if (
                    user_words[word_index][letter_index]
                    != computer_words[word_index][letter_index]
                ):
                    errors += 1

            # count any additional characters in the user's word as mistakes
            errors += abs(len(user_words[word_index]) - len(computer_words[word_index]))

        # handle case if user's input is longer
        if len(user_words) > len(computer_words):
            additional_words = user_words[len(computer_words) :]
            for word in additional_words:
                errors += len(word)

        return errors
